//Connection
"use strict";

const mysql = require('mysql');
const MysqlConfig = require('./Config');
const symbols = {
    oriConn: Symbol('originConnection'),
    isAlive: Symbol('isAlive'),
    isPoolConn: Symbol('isPoolConnection')
}




/**
 * The standard function of a promise.
 * @param resolve 
 * @param reject 
 */
function promiseFn(resolve, reject) {
    return function (err, ...args) {
        if (err)
            reject(err);
        else if (args.length === 1)
            resolve(args[0]);
        else
            resolve(args);
    }
}




class Connection {
    get originConnection() { return this[symbols.oriConn] }
    get isAlive() { return this[symbols.isAlive] }
    get config() { return this[symbols.oriConn].config }
    get threadId() { return this[symbols.oriConn].threadId }
    get isPoolConnection() { return this[symbols.isPoolConn] }

    /**
     * Constructor.
     * @param {MysqlConnection|Object|MysqlConfig|String} config config object or connection string or mysql connection
     * @param {Boolean} isPoolConn means the connection is in a pool or not.
     */
    constructor(config, isPoolConn = false) {
        this[symbols.oriConn] = config.query ? config : mysql.createConnection(config);
        this[symbols.isAlive] = true;
        this[symbols.isPoolConn] = isPoolConn;
    }


    /**
     * The origin connection's function "on"'s proxy function.
     * @param {String} evtName the name of the listened event.
     * @param {Function} listner the callback excuted when the event triggered.
     */
    on(evtName, listner) {
        let conn = this[symbols.oriConn];
        return conn.on.apply(conn, arguments);
    }


    /**
     * Ternimate the connection immediately whatever there's any query in the quene or not.
     * @return {Promise}
     */
    async destroy() {
        this[symbols.oriConn].destroy();
        this[symbols.isAlive] = false;
        return;
    }


    /**
     * Ternimate the connection after all of queries completely finishing.
     * @return {Promise}
     */
    async end() {
        return new Promise((resolve, reject) => {
            this[symbols.oriConn].end(() => {
                this[symbols.isAlive] = false;
                resolve()
            });
        });
    }


    /**
     * Query one or multy sql with any of parameters.
     * @param {String} cmd the sql that would be queried.
     * @param {Array} params the parameters.
     * @return {Promise} results
     */
    async query(cmd, params) {
        let conn = this[symbols.oriConn];
        let args = [cmd];
        if (params)
            args.push(params);
        return new Promise((resolve, reject) => {
            args.push(promiseFn(resolve, reject));
            conn.query.apply(conn, args);
        });
    }


    /**
     * Begin transaction of the connection
     * @return {Promise}
     */
    async begin() {
        return new Promise((resolve, reject) => {
            this[symbols.oriConn].beginTransaction(promiseFn(resolve, reject));
        });
    }


    /**
     * Commit transaction of the connection
     * @return {Promise}
     */
    async commit() {
        return new Promise((resolve, reject) => {
            this[symbols.oriConn].commit(promiseFn(resolve, reject));
        });
    }


    /**
     * Rollback transaction of the connection
     * @return {Promise}
     */
    async rollback() {
        return new Promise((resolve, reject) => {
            this[symbols.oriConn].rollbak(promiseFn(resolve, reject));
        });
    }
}









//output
module.exports.default = module.exports = Connection;